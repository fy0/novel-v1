# 剧情脚本测试2

测试性的剧情脚本语言

注意，只是v2草案，语法还可能修改

设计思路:
- 以写作为主，为文案人员设计，只有极少的特殊语法且很难误触
- 剧情文本由被称为“段落”的文本段构成，能够轻易转换为剧情流程图，再从流程图转换为原文
- 易于嵌入各种游戏/文本引擎（主要目标为js、c#和golang）

简易演示: https://gamex.weizaima.com/s/novel-v2/
v1版本请切换分支查看，末尾会写每个迭代的改动。

## 语法介绍

语法三条：
* `:` 开头的行代表段落开始，至少需要一个段落
* `@{` `}` 框住的部分为嵌入代码，`@{`必须写在行首 
* 其余为普通剧情文本，剧情文本中可用 `{}` 插入变量，如：`玩家的角色名叫做{charname}`

以下是详细介绍。

### 基础写法

```
:第一段
这是第一段文本

:第二段
这是第二段文本

想写几行写几行
   任何格式都会原样输出

:第三段
结束
```


执行结果:
```
这是第一段文本

这是第二段文本
想写几行写几行
   任何格式都会原样输出
结束
```


整个文本除了":"开头的部分，都会被顺序输出。

### 关于分段

目前只有两个特殊语法，第一个是":"开头的行，完整规则如下：

```
:分段标题[条件][下一分段]
```

注: 为了将对原始文本影响减到最小，冒号必须另起一行，前面不能空格

分段标题、条件、下一分段三项均可省略，举例说明：

#### 首先来看全省略，两个分段，不做命名
```
:
这是开始

:
这是结束
```

执行结果:
```
这是开始
这是结束
```

#### 省略名字和条件

```cmd
:[][结束]
这是开始，会直接跳到结束

:
这段跳过

:结束
这是结束
```

执行结果:
```
这是开始，会直接跳到结束
这是结束
```

#### 满足条件时经过

这里有一个新的语法，暂时只需要知道这是为 x 取了一个 1-10 的随机值

```
:
有一半可能跳过第二段
@{ x = d10 }

:[x > 5]
第二段

:结束
这是结束
```

执行结果:
```
有一半可能跳过第二段
第二段
这是结束
```


#### 满足条件时经过 - 加强版

假设一个事件有几种分支选项，我们希望对每种可能进行判断，可以这么做：

```
:
三个分支
@{ x = d3 }

:[x == 1][结束]
分支A

:[x == 2][结束]
分支B

:[x == 3][结束]
分支C

:结束
这是结束
```

执行结果:
```
三个分支
分支C
这是结束
```

说明: 如果把分支选项转成图像，这里会出现起点到A、B、C，然后这三个点分别连到终点。

### 关于代码嵌入

目前仅是一个剧本引擎，用户可以自行选择自己喜欢的脚本进行嵌入，不必学习新的语言，

例如你的项目在使用JS，可以接入js，使用lua可以接入lua，但是总体上说，推荐使用C系的语言。

实现这两个回调函数就行了，第一个用于打印文本。

第二个用于执行嵌入的代码。注意，我们倾向于剧本状态与显示完全同步。这是什么意思呢？

例如说，你那里打印文本可能是异步的，文本没有显示出来，函数就已经返回了。我们希望尽可能避免这一点。

如果你在使用JS等语言，这个回调函数是支持异步的，即可以写一个 async function。
```
	TextCallback func(sl *StoryLoader, text string, line, col int) error
	CodeCallback func(sl *StoryLoader, expr string, returnAs string) (any, error) // returnAs: bool, string, any
```

这两个回调函数怎样工作呢？例如说这样一段话：

```
:开场
这是一个早上，{charname}被闹钟声惊醒。
他看了看时间，准备起床。
“又是无聊的一天。”他想。
```

这个分段的第一行，会被切成三个指令：
```
text 这是一个早上，
text (code {charname})
text 被闹钟声惊醒。
```

现在你应该明白了。

#### 建议实现的函数

出于最基本的需求，建议在你插入的脚本引擎中实现 `select` 函数和 `input` 函数。

```
function select(...args): Number; // 返回的数字代表选择了第几项
function input(text: String): String; // 和python的input完全一样，不做过多解释
```

这样就能满足最简单的剧情交互需求了。

```
:开场
@{ val = select('选项A', '选项B', '选项C') }

:[val == 1][end]
选项A

:[val == 2][end]
选项B

:[val == 3][end]
选项C

:end
```

## 其他

目前关于跨文件跳转的设想是建立一个

`@{ use('另一个脚本文件.ns') }`

这样的函数。再看吧。


### 编译后的数据示例

原文:
```
:第一段
这是D10: {d10} 结束 {5} \{444}
@{ 666 }
第一段结束

: 结尾
```

编译后：
```
分段 第一段 pos [1 1 0]
{"pos":[2,1,11],"text":"这是D10: "}
{"pos":[2,8,22],"type":"codeInText","code":"d10"}
{"pos":[2,13,27],"text":" 结束 "}
{"pos":[2,17,35],"type":"codeInText","code":"5"}
{"pos":[2,20,38],"text":" {444}"}
{"pos":[2,1,11],"text":"\n"}
{"pos":[3,1,46],"type":"codeBlock","code":" 666 "}
{"pos":[4,1,55],"text":"第一段结束"}
{"pos":[4,1,55],"text":"\n"}
分段 结尾 pos [9 1 67]
```

## 与v1的修改

* `@{}!` 修改为 `@{}`
* 暂时删除了`@`标号
* 支持在文本中用 `{}` 来嵌入表达式，写起来方便一点
* 简化执行函数，现在runtime需要做的事情更少了
* 分离了内置的逻辑脚本，现在是逻辑脚本是仅供选配的
* js示例现在使用一个接近原生的版本，解析器从最小化后2408kb降至最小化前132kb，gzip后从445kb降至21kb，使用的脚本语言更换为js
