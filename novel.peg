{
{{ if eq .Target "go" }}
package novelscript

import "strings"

type ParserCustomData struct {
	CurIndex   int
	Name2Index map[string]int
}

func (d *ParserCustomData) getNextIndex() int {
    // 如果我是第0段，那next是1
    d.CurIndex += 1
    return d.CurIndex
}

func (d *ParserCustomData) setSectionIndex(name string) error {
    if name == "" {
        return nil
    }
    if d.Name2Index == nil {
        d.Name2Index = map[string]int{}
    }

    if _, exists := d.Name2Index[name]; exists {
        return errors.New("section name must be unique")
    }

    d.Name2Index[name] = d.CurIndex
    return nil
}

func parseFilterNil[T any](lines any, t T) []*T {
	var items []*T
	if x, ok := lines.([]any); ok {
		for _, i := range x {
			if i != nil {
				if _, ok2 := i.([]any); ok2 {
					items = append(items, parseFilterNil(i, t)...)
				} else {
					items = append(items, i.(*T))
				}
			}
		}
	}
	return items
}

func parseReturnTextSectionLine(c *current, text string) any {
	return &StorySectionLine{
		Type: "", // 作为最常见种类，故意置空，节省空间
		Pos:  []int{c.pos.line, c.pos.col, c.pos.offset},
		Text: text,
	}
}

func parseReturnInvokeSectionLine(c *current, name string, params []string) any {
	return &StorySectionLine{
		Type:   "invoke",
		Pos:    []int{c.pos.line, c.pos.col, c.pos.offset},
		Name:   name,
		Params: params,
	}
}

func parseReturnCodeSectionLine(c *current, typeName string, code string) any {
	return &StorySectionLine{
		Type: typeName,
		Pos:  []int{c.pos.line, c.pos.col, c.pos.offset},
		Code: code,
	}
}

func gatherParams(first any, v any) []string {
	if v == nil {
		return nil
	}

	items := []string{first.(string)}
	if x, ok := v.([]any); ok {
		for _, i := range x {
			items = append(items, i.(string))
		}
	}
	return items
}

func toStr(x []byte) string {
	return string(x)
}

func toStrWithTrim(x []byte) string {
	return strings.TrimSpace(string(x))
}

{{ else }}
class ParserCustomData {
    public var curIndex = 0;
    public var name2Index = new Map<String, Int>();
	public function new() {}

	public function getNextIndex():Int {
        // 如果我是第0段，那next是1
        this.curIndex += 1;
        return this.curIndex;
	}

	public function setSectionIndex(name:Null<String>):Exception {
		if (name == "" || name == null) {
			return null;
		}
		if (this.name2Index.exists(name)) {
			return new Exception("section name must be unique");
		}
		this.name2Index[name] = this.curIndex;
		return null;
	}
}

function parseFilterNil(lines:Any):Array<Any> {
	var items:Array<Any> = [];
	if (Std.isOfType(lines, Array)) {
		var x:Array<Any> = cast lines;
		for (i in x) {
			if (i != null) {
				if (Std.isOfType(i, Array)) {
					for (j in parseFilterNil(i)) {
						items.push(j);
					}
				} else {
					items.push(i);
				}
			}
		}
	}
	return items;
}

function parseReturnTextSectionLine(c:Current, text:String) {
	return {
		pos: [c.pos.line, c.pos.col, c.pos.offset],
		type: "", // 作为最常见种类，故意置空，节省空间
		text: text,
	};
}

function parseReturnInvokeSectionLine(c:Current, name:String, params:Array<String>) {
	return {
		pos: [c.pos.line, c.pos.col, c.pos.offset],
		type: "invoke",
		name: name,
		params: params,
	};
}

function parseReturnCodeSectionLine(c:Current, typeName:String, code:String) {
	return {
		pos: [c.pos.line, c.pos.col, c.pos.offset],
		type: typeName,
		code: code,
	};
}

function gatherParams(first:Any, v:Any):Array<String> {
	if (v == null) {
		return null;
	}
	var items:Array<String> = [first];
	for (i in parseFilterNil(v)) {
		items.push(i);
	}
	return items;
}

var toStr = (x:String) -> x;
var toStrWithTrim = (x:String) -> StringTools.trim(x);
var nil = null;
{{ end }}
}

// ENTRY POINT
input <- sp x:nodes !. {
    return x;
}

nodes <- nodes:(node*) {
{{ if eq .Target "go" }}
    var items []*StorySection
	if x, ok := nodes.([]any); ok {
		for _, i := range x {
		    items = append(items, i.(*StorySection))
		}
	}
    return &Story{Items: items};
{{ else }}
    return new Types.Story(nodes);
{{ end }}
}

_nodeCond <- '[' cond:CodeExpr2? ']' { return cond; }
_nodeNext <- '[' name:identifier ']' { return name; }

node <- nodeType1 / nodeType2

nodeType1 <- ':' spNoCR name:identifier? spNoCR (cond:_nodeCond spNoCR next:_nodeNext?) spNoCR cr2 lines:nodeLines {
{{ if eq .Target "go" }}
    nameStr, _ := name.(string)
    condStr, _ := cond.(string)
    nextStr, _ := next.(string)
    items := parseFilterNil(lines, StorySectionLine{})

    if err := c.data.setSectionIndex(nameStr); err != nil {
        p.addErr(err)
        return nil
    }
    return &StorySection{
        Pos: []int{c.pos.line, c.pos.col, c.pos.offset},
        Name: nameStr,
        Lines: items,
        Condition: condStr,
        Next: nextStr,
        NextIndex: c.data.getNextIndex(),
    };
{{ else }}
    var e = c.data.setSectionIndex(name);
    if (e != null) {
        p.addErr(e);
        return null;
    }

    return {
        pos:[c.pos.line, c.pos.col, c.pos.offset],
        name:name,
        lines:parseFilterNil(lines),
        condition:cond,
        next:next,
        nextIndex: c.data.getNextIndex(),
    };
{{ end }}
}

nodeType2 <- ':' spNoCR name:identifier? spNoCR cr2 lines:nodeLines {
{{ if eq .Target "go" }}
    nameStr, _ := name.(string)
    items := parseFilterNil(lines, StorySectionLine{})

    if err := c.data.setSectionIndex(nameStr); err != nil {
        p.addErr(err)
        return nil
    }
    return &StorySection{
        Pos: []int{c.pos.line, c.pos.col, c.pos.offset},
        Name: nameStr,
        Lines: items,
        NextIndex: c.data.getNextIndex(),
    };
{{ else }}
    var e = c.data.setSectionIndex(name);
    if (e != null) {
        p.addErr(e);
        return null;
    }
    return {
        pos:[c.pos.line, c.pos.col, c.pos.offset],
        name:name,
        lines:parseFilterNil(lines),
        nextIndex: c.data.getNextIndex(),
    };
{{ end }}
}

nodeLines <- lines:nodeLine* sp { return lines; }

nodeLine <- nodeLineTypeComment / nodeLineType2 / nodeLineCommonText

nodeLineTypeComment <- '@' '#' (!cr .)+ cr sp

_curLine <- (!cr .)+ { return toStr(c.text); }
nodeLineType1x <- '@' !'{' expr:_curLine cr2 {
    // return parseReturnCodeSectionLine(c, "@", expr.(string));
}

nodeLineType1 <- '@' name:identifier params:funcInvoke sp {
{{ if eq .Target "go" }}
    return parseReturnInvokeSectionLine(c, name.(string), params.([]string))
{{ else }}
    return parseReturnInvokeSectionLine(c, name, params);
{{ end }}
}


// _storyNodeCodeBlock <- ( ( !"}!" . )* ) { return toStrWithTrim(c.text); }

nodeLineType2 <- "@{" code:Code ("}!" / "}") spNoCR cr2 {
{{ if eq .Target "go" }}
    return parseReturnCodeSectionLine(c, "codeBlock", code.(string));
{{ else }}
    return parseReturnCodeSectionLine(c, "codeBlock", code);
{{ end }}
}

_nltEscape <- "\\{" { return "{"; }
_nltChar <- [^\r\n{] { return toStr(c.text); }
nodeLineText <- items:((_nltEscape / _nltChar)+) {
{{ if eq .Target "go" }}
    var items2 []string
    for _, i := range items.([]any) {
        items2 = append(items2, i.(string));
    }
    text := strings.Join(items2, "")
    return parseReturnTextSectionLine(c, text);
{{ else }}
	var items2 = [];
	if (Std.isOfType(items, Array)) {
		var itemsX:Array<Any> = cast items;
		for (i in itemsX) {
			items2.push(i);
		}
	}
	var text = items2.join("");
	return parseReturnTextSectionLine(c, text);
{{ end }}
}

nodeLineExprBlock <- '{' expr:CodeExpr '}' {
{{ if eq .Target "go" }}
    return parseReturnCodeSectionLine(c, "codeInText", expr.(string));
{{ else }}
    return parseReturnCodeSectionLine(c, "codeInText", expr);
{{ end }}
}

// Line not starts with [:@], normal text and {expr} are available.
nodeLineCommonText <- ![:@] items:(( nodeLineText / nodeLineExprBlock )*) cr2 {
{{ if eq .Target "go" }}
    v := parseReturnTextSectionLine(c, "\n");
    items2, ok := items.([]any)
    if !ok {
        items2 = []any{}
    }
    items2 = append(items2, v);
    return items2;
{{ else }}
	var x = parseReturnTextSectionLine(c, "\n");
	var items2:Array<Any> = null;
	if (Std.isOfType(items, Array)) {
		items2 = cast items;
		items2.push(x);
	}
	return items2;
{{ end }}
}

funcInvoke <- '(' sp ')' { {{ if eq .Target "go" }} return []string{} {{ else }} return []; {{ end }} }
            / '(' sp first:_codeExpr rest:(funcInvokeParamExtend*) ')' { return gatherParams(first, rest); }

funcInvokeParamExtend <- sp ',' sp e:_codeExpr { return e; }

// codeExpr <- [^\n,)]+ { return toStr(c.text); }
_codeExpr <- _codeExpr2 { return toStr(c.text); }

_codeExpr2 <- identifier
           / integer
           / [0-9]* '.' [0-9]+
           / stringType

stringType <- (codeString / '`' [^`]* '`') { return toStr(c.text); }

codeString ← '"' ( !EscapedChar . / '\\' EscapeSequence )* '"'
           / '\'' ( !EscapedChar2 . / '\\' EscapeSequence2 )* '\''

EscapedChar2 ← [\x00-\x1f'\\]
EscapeSequence2 ← SingleCharEscape2 / UnicodeEscape
SingleCharEscape2 ← ['\\/bfnrt]

String ← '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    // c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    // return strconv.Unquote(string(c.text))
}
EscapedChar ← [\x00-\x1f"\\]
EscapeSequence ← SingleCharEscape / UnicodeEscape
SingleCharEscape ← ["\\/bfnrt]
UnicodeEscape ← 'u' HexDigit HexDigit HexDigit HexDigit
DecimalDigit ← [0-9]
NonZeroDecimalDigit ← [1-9]
HexDigit ← [0-9a-f]i

integer <- '-'? [0-9]+ {
{{ if eq .Target "go" }}
    val, _ := strconv.Atoi(string(c.text));
    return val;
{{ else }}
    return Std.parseInt(c.text);
{{ end }}
}

identifier <- xidStart xidContinue* {
    return toStr(c.text);
}

// L + Other_ID_Start
xidStart <- [_\p{L}\p{Other_ID_Start}]

// xid_start + Nl + Mn + Mc + Nd + Pc + Other_ID_Continue \u200C\u200D
xidContinue <- [\p{L}\p{Other_ID_Start}\p{Nl}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}]

sp "whitespace" <- [ \n\t\r]*

spNoCR <- [ \t]*

cr <- [\r\n]
cr2 <- '\r'? '\n'

// 仅支持 // 为注释，支持'' "" `` 三种文本的脚本语言
SourceChar <- .
Comment <- MultiLineComment / SingleLineComment
MultiLineComment <- "/*" ( !"*/" SourceChar )* "*/"
MultiLineCommentNoLineTerminator <- "/*" ( !( "*/" / cr ) SourceChar )* "*/"
SingleLineComment <- !("//{") "//" ( !cr SourceChar )*

CodeStringLiteral <- '"' (`\"` / `\\` / [^"\r\n])* '"' /
                    '`' [^`]* '`' /
                    '\'' (`\'` / `\\` / [^']+)* '\''


Code <- ( ( Comment / CodeStringLiteral / ![{}] SourceChar )+ / '{' Code '}' )* { return toStr(c.text); }
CodeExpr <- ( (CodeStringLiteral / ![{}] SourceChar)+ / '{' CodeExpr '}' )* { return toStr(c.text); }
CodeExpr2 <- ( (CodeStringLiteral / ![[\]] SourceChar)+ / '[' CodeExpr2 ']' )* { return toStr(c.text); }
