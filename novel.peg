{
{{ if eq .target "go" }}
package novelscript

import "strings"

type ParserCustomData struct {
	CurIndex   int
	Name2Index map[string]int
}

func (d *ParserCustomData) getNextIndex() int {
    // 如果我是第0段，那next是1
    d.CurIndex += 1
    return d.CurIndex
}

func (d *ParserCustomData) setSectionIndex(name string) error {
    if name == "" {
        return nil
    }
    if d.Name2Index == nil {
        d.Name2Index = map[string]int{}
    }

    if _, exists := d.Name2Index[name]; exists {
        return errors.New("section name must be unique")
    }

    d.Name2Index[name] = d.CurIndex
    return nil
}

func parseFilterNil[T any](lines any, t T) []*T {
	var items []*T
	if x, ok := lines.([]any); ok {
		for _, i := range x {
			if i != nil {
				items = append(items, i.(*T))
			}
		}
	}
	return items
}

func gatherParams(first any, v any) []string {
	if v == nil {
		return nil
	}

	items := []string{first.(string)}
	if x, ok := v.([]any); ok {
		for _, i := range x {
			items = append(items, i.(string))
		}
	}
	return items
}

func retWrap(a any, err error) (any, error) {
	return a, err
}

func toStr(x []byte) string {
	return string(x)
}

func toStrWithTrim(x []byte) string {
	return strings.TrimSpace(string(x))
}

{{ else }}
class ParserCustomData {
    public var curIndex = 0;
    public var name2Index = new Map<String, Int>();
	public function new() {}

	public function getNextIndex():Int {
        // 如果我是第0段，那next是1
        this.curIndex += 1;
        return this.curIndex;
	}

	public function setSectionIndex(name:Null<String>):Exception {
		if (name == "" || name == null) {
			return null;
		}
		if (this.name2Index.exists(name)) {
			return new Exception("section name must be unique");
		}
		this.name2Index[name] = this.curIndex;
		return null;
	}
}

function parseFilterNil(lines:Any):Array<Any> {
	var items:Array<Any> = [];
	if (Std.isOfType(lines, Array)) {
		var x:Array<Any> = cast lines;
		for (i in x) {
			if (i != null) {
				items.push(i);
			}
		}
	}
	return items;
}

function gatherParams(first:Any, v:Any):Array<String> {
	if (v == null) {
		return null;
	}
	var items:Array<String> = [first];
	for (i in parseFilterNil(v)) {
		items.push(i);
	}
	return items;
}

var retWrap = (a:Any, err:Exception) -> {val: a, err: err};
var toStr = (x:String) -> x;
var toStrWithTrim = (x:String) -> StringTools.trim(x);
var nil = null;
{{ end }}
}

input <- sp x:nodes !. {
    return retWrap(x, nil);
}

nodes <- nodes:(node*) {
{{ if eq .target "go" }}
    var items []*StorySection
	if x, ok := nodes.([]any); ok {
		for _, i := range x {
		    items = append(items, i.(*StorySection))
		}
	}
    return retWrap(&Story{Items: items}, nil);
{{ else }}
    return retWrap(new Types.Story(nodes), nil);
{{ end }}
}

_nodeCondContent <- [^\]]+ { return retWrap(toStr(c.text), nil); }
_nodeCond <- '[' cond:_nodeCondContent? ']' { return retWrap(cond, nil); }
_nodeNext <- '[' name:identifier ']' { return retWrap(name, nil); }

node <- nodeType1 / nodeType2

nodeType1 <- ':' spNoCR name:identifier? spNoCR (cond:_nodeCond spNoCR next:_nodeNext?) spNoCR cr lines:nodeLines {
{{ if eq .target "go" }}
    nameStr, _ := name.(string)
    condStr, _ := cond.(string)
    nextStr, _ := next.(string)
    items := parseFilterNil(lines, StorySectionLine{})

    if err := c.data.setSectionIndex(nameStr); err != nil {
        return nil, err
    }
    return retWrap(&StorySection{
        Pos: []int{c.pos.line, c.pos.col, c.pos.offset},
        Name: nameStr,
        Lines: items,
        Condition: condStr,
        Next: nextStr,
        NextIndex: c.data.getNextIndex(),
    }, nil);
{{ else }}
    var e = c.data.setSectionIndex(name);
    if (e != null) {
        return retWrap(null, e);
    }

    return retWrap({
        pos:[c.pos.line, c.pos.col, c.pos.offset],
        name:name,
        lines:parseFilterNil(lines),
        condition:cond,
        next:next,
        nextIndex: c.data.getNextIndex(),
    }, nil);
{{ end }}
}

nodeType2 <- ':' name:identifier? spNoCR cr lines:nodeLines {
{{ if eq .target "go" }}
    nameStr, _ := name.(string)
    items := parseFilterNil(lines, StorySectionLine{})

    if err := c.data.setSectionIndex(nameStr); err != nil {
        return nil, err
    }
    return retWrap(&StorySection{
        Pos: []int{c.pos.line, c.pos.col, c.pos.offset},
        Name: nameStr,
        Lines: items,
        NextIndex: c.data.getNextIndex(),
    }, nil);
{{ else }}
    var e = c.data.setSectionIndex(name);
    if (e != null) {
        return retWrap(null, e);
    }

    return retWrap({
        pos:[c.pos.line, c.pos.col, c.pos.offset],
        name:name,
        lines:parseFilterNil(lines),
        nextIndex: c.data.getNextIndex(),
    }, nil);
{{ end }}
}

nodeLines <- lines:nodeLine* sp { return retWrap(lines, nil); }

nodeLine <- nodeLineTypeComment / nodeLineType1 / nodeLineType2 / nodeLineType3

nodeLineTypeComment <- '@' '#' (!cr .)+ cr sp { return retWrap(nil, nil); }

nodeLineType1 <- '@' name:identifier params:funcInvoke sp {
{{ if eq .target "go" }}
    nameStr, _ := name.(string)

    return retWrap(&StorySectionLine{
        Pos: []int{c.pos.line, c.pos.col, c.pos.offset},
        Name: nameStr,
        Params: params.([]string),
    }, nil);
{{ else }}
    return retWrap({
        type: "",
        pos:[c.pos.line, c.pos.col, c.pos.offset],
        name:name,
        params:params,
    }, nil);
{{ end }}
}

nodeLineType2 <- "@{" code:_storyNodeCodeBlock "}!" spNoCR cr {
{{ if eq .target "go" }}
    return retWrap(&StorySectionLine{
        Type: "code",
        Pos: []int{c.pos.line, c.pos.col, c.pos.offset},
        Code: code.(string),
    }, nil);
{{ else }}
    return retWrap({
        pos:[c.pos.line, c.pos.col, c.pos.offset],
        type:'code',
        code:code,
    }, nil);
{{ end }}
}

nodeLineType3Text <- ( ![:@] [^\r\n]* cr )+ { return retWrap(toStr(c.text), nil); }
nodeLineType3 <- text:nodeLineType3Text {
{{ if eq .target "go" }}
    if strings.TrimSpace(text.(string)) == "" {
        return nil, nil
    }
    return retWrap(&StorySectionLine{
        Pos: []int{c.pos.line, c.pos.col, c.pos.offset},
        Name: "sayRaw",
        Params: []string{text.(string)},
    }, nil)
{{ else }}
    if (StringTools.trim(c.text) == "") {
        return retWrap(null, null);
    }
    return retWrap({
        pos:[c.pos.line, c.pos.col, c.pos.offset],
        name:'sayRaw',
        type:"",
        params:[text],
    }, nil);
{{ end }}
}

_storyNodeCodeBlock <- ( ( !"}!" . )* ) { return retWrap(toStrWithTrim(c.text), nil); }

funcInvoke <- '(' sp ')' { {{ if eq .target "go" }} return retWrap([]string{}, nil) {{ else }} return retWrap([], nil); {{ end }} }
            / '(' sp first:codeExpr rest:(funcInvokeParamExtend*) ')' { return retWrap(gatherParams(first, rest), nil); }

funcInvokeParamExtend <- sp ',' sp e:codeExpr { return retWrap(e, nil); }

// codeExpr <- [^\n,)]+ { return retWrap(toStr(c.text), nil); }
codeExpr <- codeExpr2 { return retWrap(toStr(c.text), nil); }

codeExpr2 <- identifier
           / integer
           / [0-9]* '.' [0-9]+
           / stringType

stringType <- (codeString / '`' [^`]* '`') { return retWrap(toStr(c.text), nil); }

codeString ← '"' ( !EscapedChar . / '\\' EscapeSequence )* '"'
           / '\'' ( !EscapedChar2 . / '\\' EscapeSequence2 )* '\''

EscapedChar2 ← [\x00-\x1f'\\]
EscapeSequence2 ← SingleCharEscape2 / UnicodeEscape
SingleCharEscape2 ← ['\\/bfnrt]

String ← '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    return strconv.Unquote(string(c.text))
}
EscapedChar ← [\x00-\x1f"\\]
EscapeSequence ← SingleCharEscape / UnicodeEscape
SingleCharEscape ← ["\\/bfnrt]
UnicodeEscape ← 'u' HexDigit HexDigit HexDigit HexDigit
DecimalDigit ← [0-9]
NonZeroDecimalDigit ← [1-9]
HexDigit ← [0-9a-f]i

integer <- '-'? [0-9]+ {
{{ if eq .target "go" }}
    return strconv.Atoi(string(c.text));
{{ else }}
    return retWrap(Std.parseInt(c.text), nil);
{{ end }}
}

identifier <- xidStart xidContinue* {
    return retWrap(toStr(c.text), nil);
}

// L + Other_ID_Start
xidStart <- [_\p{L}\p{Other_ID_Start}]

// xid_start + Nl + Mn + Mc + Nd + Pc + Other_ID_Continue \u200C\u200D
xidContinue <- [\p{L}\p{Other_ID_Start}\p{Nl}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}]

sp "whitespace" <- [ \n\t\r]*

spNoCR <- [ \t]*

cr <- [\r\n]
